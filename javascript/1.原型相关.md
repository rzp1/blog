https://www.cnblogs.com/wangfupeng1988/p/3977924.html
https://github.com/xd-tayde/blog/blob/master/interview-1.md

## 原型/构造函数/实例

- 原型(prototype): 一个简单的对象用于实现对象的继承，可以理解为对象的爹，显式原型 prototype 隐式子 **proto**
- 构造函数(constructor): 可以通过 new 来新建一个 对象实例的函数, 构造函数可以通过 prototype 指向原型
- 实例(instance): 通过构造函数和 new 创建出来的对象，便是实例。 实例通过**proto**指向原型，通过 constructor 指向构造函数。

```JavaScript
实例.__proto__ === 原型

原型.constructor === 构造函数

构造函数.prototype === 原型

// 这条线其实是是基于原型进行获取的，可以理解成一条基于原型的映射线
// 例如:
// const o = new Object()
// o.constructor === Object   --> true
// o.__proto__ = null;
// o.constructor === Object   --> false
// 注意: 其实实例上并不是真正有 constructor 这个指针，它其实是从原型链上获取的
//      instance.hasOwnProperty('constructor') === false
实例.constructor === 构造函数

```

图片理解
<img src="../images/168e9d9b940c4c6f.png">

## 原型链


原型链是由原型对象组成，每个对象都有 **proto** 属性，指向了创建该对象的构造函数的原型，**proto** 将对象连接起来组成了原型链。是一个用来实现继承和共享属性的有限的对象链。

- 属性查找机制: 当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象 Object.prototype，如还是没找到，则输出 undefined；
- 属性修改机制: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: b.prototype.x = 2；但是这样会造成所有继承于该对象的实例的属性发生改变。

## instanceof
instanceof 运算符用于测试构造函数的 prototype 属性是否出现在对象原型链中的任何位置

```
instance.[__proto__...] === constructor.prototype
```
https://segmentfault.com/a/1190000018874474

## new 运算符的执行过程

```JavaScript
new People('12') = {
  var obj = {} 或者 var obj = new Object() // 创建一个空对象;
  obj.__proto__ = People.prototype // 将该隐式原型原型指向构造函数显式原型，建立对象和原型直接的对应关系。
  People.call(obj, "12") // 将构造函数中this指向创建的obj对象，并传入参数"12"
  return obj // 返回obj对象，person指向创建的obj对象(对象类型赋值为按引用传递，obj与person指向同一个对象)
}
```

## 执行上下文

## this

## 闭包

## 变量提升

## ES5/ES6 的继承除了写法以外还有什么区别？